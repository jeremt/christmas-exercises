/**
 * @typedef {import('./testApi.d.ts').TestResult} TestResult
 */

/**
 * Global object that contains all methods to test exercises and some useful
 * data such as source code.
 */
this.__codePassport = {
    /**
     * The HTML current source code of the exercise.
     */
    html: "",

    /**
     * The CSS current source code of the exercise.
     */
    css: "",

    /**
     * The JavaScript current source code of the exercise.
     */
    js: "",

    /**
     * All the logs generated by `console.log()`
     */
    logs: "",

    /**
     * The error message if there is one.
     */
    error: "",
    /**
     * Contains all the tests run for the current call to `runTests()`.
     * @type TestResult[]
     */
    tests: [],
    /**
     * Test an abritrary condition.
     * @param {boolean} success The result of the condition to assert.
     * @param {string} failedMessage The message to display if `success === false`.
     * @param {string|undefined} successMessage The message to display if `success === true`, fallback to failedMessage.
     * @example __codePassport.assert(age > 10, `Age should be at least 10, not ${age}.`, "Age must be at least 10.");
     */
    testAssert(success, failedMessage, successMessage) {
        this.tests.push({
            type: "assert",
            success,
            successMessage,
            failedMessage,
        });
    },

    /**
     * Test if `console.log()` has log exactly the given messages so far. Be careful, \n are important!
     * @param {string} expected The expected logs value.
     * @example __codePassport.testLogs('Bonjour tout le monde !\nCeci est mon premier code JavaScript :)\n');
     */
    testLogs(expected) {
        this.tests.push({
            type: "logs",
            success: this.logs === expected,
            result: this.logs,
            expected,
        });
    },

    /**
     * Call the given function without tests.
     * @param {Function} func The function to call.
     * @param {unknown[]} params The parameters to pass to the function.
     * @example __codePassport.callFunc(iLove, ['les pommes']);
     */
    callFunc(func, params) {
        func?.(...params);
        this.tests.push({
            type: "callFunc",
            success: true,
            exists: func !== undefined,
            funcName: func.name,
            params,
        });
    },

    /**
     * Call the given function without tests.
     * @param {Record<string, any>} self The object on which the method should be called
     * @param {string} methodName The name of the method to call.
     * @param {unknown[]} params The parameters to pass to the method.
     * @example __codePassport.callMethod(testCalculator, 'addDigit', ['4']);
     */
    callMethod(self, methodName, params) {
        self[methodName]?.(...params);
        this.tests.push({
            type: "callFunc",
            success: true,
            exists: self[methodName] !== undefined,
            funcName: `${self.__proto__.constructor.name}.${methodName}`,
            params,
        });
    },

    /**
     * Call the given function with the parameters and check whether its return value is equal to expected.
     * @param {Function} func The function to call.
     * @param {unknown[]} params The parameters to pass to the function.
     * @param {unknown} expected The expected return value of the function.
     * @example __codePassport.testFunc(hotOrCold, ['violet'], 'cold');
     */
    testFunc(func, params, expected) {
        const result = func?.(...params);
        this.tests.push({
            type: "func",
            success: JSON.stringify(result) === JSON.stringify(expected),
            exists: func !== undefined,
            funcName: func.name,
            params: params.map((p) => (typeof p === "function" ? p.toString() : p)), // üí©
            result,
            expected,
        });
    },

    /**
     * Call and await the given function with the parameters and check whether its return value is equal to expected.
     * @param {Function} func The function to call.
     * @param {unknown[]} params The parameters to pass to the function.
     * @param {unknown} expected The expected return value of the function.
     * @example await __codePassport.testAsyncFunc(getDogMessage, [1], `Woof! I'm Buddy!`);
     */
    async testAsyncFunc(func, params, expected) {
        // üí© maybe simply using await in testFunc is enough
        const result = await func?.(...params);
        this.tests.push({
            type: "func",
            success: JSON.stringify(result) === JSON.stringify(expected),
            exists: func !== undefined,
            funcName: func.name,
            params: params.map((p) => (typeof p === "function" ? p.toString() : p)), // üí©
            result,
            expected,
        });
    },

    /**
     * Check whether the given function throws an error when its called.
     * @param {Function} func The function to call.
     * @param {unknown[]} params The parameters to pass to the function.
     * @param {string} expected The expected value for error.message if an error is thrown.
     * @example __codePassport.testThrow(recycle, ['ü•ù'], `ü•ù n'est pas recyclable`);
     */
    testThrow(func, params, expected) {
        let errorMessage = null;
        try {
            func?.(...params);
            // if don't understand why this is not caught properly, maybe svelte does some
            // weird black magic
        } catch (error) {
            console.log("error caught: ", error);
            errorMessage = error.message;
        }
        this.tests.push({
            type: "throw",
            success: errorMessage === expected,
            exists: func !== undefined,
            funcName: func.name,
            params,
            errorMessage,
            expected,
        });
    },

    /**
     * Test whether the value of the given variable is (deeply) equal to the expected value.
     * @template T
     * @param {string} varName The name of the variable.
     * @param {T} value The value or the variable to check.
     * @param {T} expected The expected value to compare it with.
     * @example __codePassport.testVar('age', age, 18);
     * @example __codePassport.testVar('h1.innerHTML', h1.innerHTML, 'Woof!');
     */
    testVar(varName, value, expected) {
        this.tests.push({
            type: "var",
            success: JSON.stringify(value) === JSON.stringify(expected),
            varName,
            value,
            expected,
        });
    },

    /**
     * Take 2 HTML element and compare if they are similare using there innerHTML method.
     * The function minifies the value before comparaison to ignore whitespaces.
     * @param {HTMLElement | undefined} el The HTML element to test.
     * @param {HTMLElement} expected The other HTML element to compare it to.
     * @example __codePassport.testHTML(__codePassport.ingredients, `<li>blanc d'≈ìuf (36g)</li><li>sucre en poudre (27g)</li><li>poudre d'amande (45g)</li><li>sucre glace (47g)</li><li>cacao en poudre (5g)</li>`);
     */
    testHTML(el, expected = "") {
        if (!el) {
            throw new Error("el cannot be undefined");
        }
        if (typeof expected === "string") {
            const tmpDiv = document.createElement("div");
            tmpDiv.innerHTML = expected;
            expected = tmpDiv;
        }
        this.tests.push({
            type: "html",
            success: this._minifyHtml(el.innerHTML) === this._minifyHtml(expected.innerHTML),
            el: {
                __isHTMLElement: true,
                tag: el.tagName.toLowerCase(),
                className: el.className,
                id: el.id,
            },
            value: el.innerHTML,
            expected: expected.innerHTML,
        });
    },

    /**
     * Test the value of a CSS property for the given element.
     * @param {HTMLElement | undefined} el The HTML element to test.
     * @param {string} propertyName The property to test
     * @param {string} expected The css value of the property.
     * @param {() => void | undefined} formatter An optional function to convert the value to the desired unit
     * @example __codePassport.testCssProperty(document.querySelector('h1'), 'color', 'rgb(255, 0, 0)');
     */
    testCssProperty(el, propertyName, expected, formatter) {
        if (!el) {
            throw new Error("el cannot be undefined");
        }
        let value = getComputedStyle(el).getPropertyValue(propertyName);
        if (formatter) {
            value = formatter(value);
        }
        this.tests.push({
            type: "css-property",
            success: value === expected,
            el: {
                __isHTMLElement: true,
                tag: el.tagName.toLowerCase(),
                className: el.className,
                id: el.id,
            },
            propertyName,
            value,
            expected,
        });
    },

    /**
     * Test the value of a CSS property for a list of elements.
     * @param {NodeList} els The HTML elements to test.
     * @param {string} propertyName The property to test
     * @param {string} expected The css value of the property.
     * @param {() => void | undefined} formatter An optional function to convert the value to the desired unit
     * @example __codePassport.testCssProperties(document.querySelectorAll('p'), 'color', 'blue', __codePassport.cssRgbToNamedColor);
     */
    testCssProperties(els, propertyName, expected, formatter) {
        if (!els || !els.length) {
            throw new Error("els must contain elements");
        }
        const values = [];
        for (const el of els) {
            let value = getComputedStyle(el).getPropertyValue(propertyName);
            if (formatter) {
                value = formatter(value);
            }
            values.push(value);
        }
        this.tests.push({
            type: "css-properties",
            success: values.every((v) => v === expected),
            el: {
                __isHTMLElement: true,
                tag: els[0].tagName.toLowerCase(),
                className: els[0].className,
                id: "",
            },
            propertyName,
            values,
            expected,
        });
    },

    /**
     * Transform a css pixel value into a rem value using the browser
     * default font size.
     * @param {string} value css pixel value
     * @returns css value in rem
     * @example __codePassport.cssPxToRem('16px'); // returns '1rem'
     */
    cssPxToRem: (value) => `${parseInt(value) / parseFloat(getComputedStyle(document.documentElement).fontSize)}rem`,

    /**
     * Transform an rgb or rgba color to an hexa color.
     * @param {string} value css rgb/rgba color value
     * @returns css color in hexa
     * @example __codePassport.cssRgbToHex('rgb(255, 0, 0)'); // returns '#ff0000'
     */
    cssRgbToHex: (value) => {
        const match = value.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/);
        if (!match) {
            throw new Error(`Invalid rgb/rgba color '${value}'`);
        }
        const r = Math.min(255, Math.max(0, parseInt(match[1])));
        const g = Math.min(255, Math.max(0, parseInt(match[2])));
        const b = Math.min(255, Math.max(0, parseInt(match[3])));
        const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

        const a = match[4] ? Math.round(parseFloat(match[4]) * 255) : "";
        return `#${hex}${a !== "" ? a.toString(16).toUpperCase().padStart(2, "0") : ""}`;
    },

    /**
     * Transform an rgb color to a named color.
     *
     * ‚ö†Ô∏è This function only handles a small subset of css colors, it returns the
     * rgb color otherwise.
     *
     * @param {string} value css rgb color value
     * @returns named css color
     * @example __codePassport.cssRgbToNamedColor('rgb(255, 0, 0)'); // returns 'red'
     */
    cssRgbToNamedColor: (value) =>
        ({
            "rgb(0, 0, 0)": "black",
            "rgb(192, 192, 192)": "silver",
            "rgb(128, 128, 128)": "gray",
            "rgb(255, 255, 255)": "white",
            "rgb(128, 0, 0)": "maroon",
            "rgb(255, 0, 0)": "red",
            "rgb(128, 0, 128)": "purple",
            "rgb(255, 0, 255)": "fuchsia",
            "rgb(0, 128, 0)": "green",
            "rgb(0, 255, 0)": "lime",
            "rgb(128, 128, 0)": "olive",
            "rgb(255, 255, 0)": "yellow",
            "rgb(0, 0, 128)": "navy",
            "rgb(0, 0, 255)": "blue",
            "rgb(0, 128, 128)": "teal",
            "rgb(0, 255, 255)": "aqua",
            "rgb(255, 192, 203)": "pink",
        }[value] ?? value),

    /**
     * Trigger an event to the given HTML element.
     * @param {HTMLElement} el The element on which the event will be triggered.
     * @param {Event} event The event that should be triggered.
     * @param {string} newValue An optional value to pass to the event (used for input event)
     * @returns {Promise<void>}
     * @example await __codePassport.triggerEvent(passwordEl, new InputEvent('input'), '123456');
     * @example await __codePassport.triggerEvent(cat, new MouseEvent('click'));
     */
    async triggerEvent(el, event, newValue = undefined) {
        el.value = newValue;
        // target must be set like so because we manually dispatch the event üò≠
        Object.defineProperty(event, "target", {writable: false, value: el});
        Object.defineProperty(event, "currentTarget", {writable: false, value: el});
        await el.dispatchEventSync(event); // dispatch the event and resolve async listeners
        this.tests.push({
            type: "triggerEvent",
            success: true,
            eventType: event.type,
            newValue,
            el: {
                __isHTMLElement: true,
                tag: el.tagName.toLowerCase(),
                className: el.className,
                id: el.id,
            },
        });
    },

    /**
     * Takes an HTML code and trim all spaces.
     * @private
     * @param {string} html The HTML string to minify.
     * @returns A minified HTML code
     */
    _minifyHtml(html) {
        return html
            .replace(/\s+/g, " ")
            .replace(/>[\s\n]+</g, "><")
            .replace(/>\s/g, ">")
            .replace(/\s</g, "<")
            .trim();
    },
};
